---
name: backend-design
description: Create backend architecture and API design specs for services, data models, auth, reliability, and integrations. Use when asked to design or refactor backend systems, define REST/GraphQL APIs, or produce a structured backend design document.
metadata:
  short-description: Backend architecture design
---

# Backend Design

## Compliance
- Check against GOLD Industry Standards guide in ~/.codex/AGENTS.override.md

## Overview
Produce a complete, review-ready backend design spec with explicit tradeoffs, compliance checks, and a fixed output contract.

Gold standard rule (Jan 2026):
All guidance, decisions, and outputs must align with industry best practices as of Jan 2026.

## When to use
- Designing or refactoring backend architecture.
- Producing a formal design spec with API contracts.
- Evaluating data, auth, observability, and reliability tradeoffs.

## Philosophy
- Favor correctness and integrity over feature speed.
- Design for safe evolution (versioning, migrations, deprecation).
- Make compliance and security explicit, not assumed.

## Guiding questions
- Why is this architecture the best fit for the domain?
- What is the smallest set of services that meets the goal?
- How will we prove correctness, reliability, and compliance?
- What will break first under scale or change?

## Decision priority stack (must follow)
1. Correctness and data integrity
2. Security and compliance
3. Reliability and observability
4. Performance and scalability
5. Developer ergonomics and delivery speed

## Inputs (ask only if blocking; max 2 questions)
1. System type: REST, GraphQL, or both
2. Compliance scope: which standards apply (if user says "all", include a superset checklist and flag legal review)

## Constraints
- Prefer minimal viable service boundaries before splitting into microservices.
- Avoid introducing new dependencies unless explicitly requested.
- Redact secrets and sensitive data by default in any logs, snippets, or output.

## Workflow (use this order)
1. Confirm scope: product goal, primary workflows, critical path, and integration surfaces.
2. Choose architecture pattern: Clean, Hexagonal, DDD, or hybrid; justify.
3. Define domain model and invariants.
4. Define API contract and versioning strategy.
5. Define data design and migration strategy.
6. Define authN/authZ model and tenanting.
7. Define reliability, observability, and performance targets.
8. Identify risks and edge cases.
9. Produce file plan and next steps.

## Output contract (always in this order)
1. SYSTEM_CONTEXT
2. ARCHITECTURE_PATTERN
3. DOMAIN_MODEL
4. API_CONTRACT
5. DATA_DESIGN
6. AUTHN_AUTHZ
7. RELIABILITY
8. OBSERVABILITY
9. PERFORMANCE
10. INTEGRATION_SURFACES
11. APPS_SDK_REQUIREMENTS
12. RISK_CHECKLIST
13. FILE_PLAN

Use `assets/backend_design_output_template.md` as the default structure.

## Outputs
- A design spec following the output contract.
- API contract guidance (REST and/or GraphQL) with examples.
- File plan and next steps.

## Examples
- \"Design a backend for a multi-tenant SaaS with RBAC and audit logs.\"
- \"Refactor our API to support both REST and GraphQL with versioning.\"

## Validation
- Confirm requirements and constraints before finalizing the design.
- Ensure API contracts align with RFC 9110 and OpenAPI/GraphQL baselines.
- Verify security, privacy, and compliance checklists are addressed.
- Fail fast: stop at the first failed gate and report it clearly.

## Standards baseline (enforce as of Jan 2026)
- HTTP semantics and status codes per RFC 9110
- OpenAPI latest published version (check `oas/latest`; 3.1.1 as of Oct 24, 2024) for REST contracts (JSON Schema 2020-12 dialect)
- GraphQL spec latest edition (Sep 2025)
- JSON (RFC 8259), JSON Schema 2020-12, YAML 1.2.1 for docs and schemas
- OWASP API Security Top 10 (2023) + OWASP Top 10 (2025)
- Compliance scopes: SOC 2, ISO/IEC 27001:2022, PCI DSS v4.0.1, HIPAA, GDPR, CCPA/CPRA (flag legal review)

Use references:
- `references/standards-baseline.md`

## Architecture pattern selection
- **Clean Architecture** when business rules must stay framework-agnostic and testable.
- **Hexagonal** when many external systems exist and swapability/testing are priorities.
- **DDD** when complex domain logic and bounded contexts are needed.
- **Hybrid** when two or more patterns are needed; explain boundaries.

## API contract rules
- Enforce resource naming, HTTP semantics, pagination, versioning, error format, rate limits, and auth.
- REST and GraphQL can coexist; avoid overlapping responsibilities.
- For both, define a stable error schema and client-facing examples.
- Include rate-limit + quota templates for REST/GraphQL and MCP tools.

Use references:
- `references/api-design-checklist.md` for REST + GraphQL validation
- `references/rest-best-practices.md` for REST patterns
- `references/graphql-schema-design.md` for GraphQL patterns

## Data design rules
- Define entities, relationships, constraints, indexing strategy, and migration/versioning.
- Model consistency boundaries (aggregates or transactions).

## Auth and compliance
- Always specify authN (token/session) and authZ (roles/scopes/policies).
- If compliance scope is "all", include a superset checklist for SOC2, ISO 27001, HIPAA, PCI DSS, GDPR, and CCPA and flag legal review.
- If Auth0 is used, enforce OAuth 2.1 aligned flows, PKCE, refresh token rotation, and token storage best practices.

## Reliability and observability
- Define idempotency strategy for writes.
- Include retry, timeout, circuit breaker, and rate-limit policies.
- Specify logs, metrics, traces, and alerting.
- Add idempotency + replay protection for MCP tools (nonce, request_id, dedupe window).

## Integration surfaces
- If clients include React/Vite/Tailwind/TS, Swift, Apps SDK UI, OpenAI widgets, MCP, Storybook, or CLI, define contract-first integration.
- If Swift clients or server-side Swift are in scope, align naming and SDK surfaces with Swift API Design Guidelines (see `references/swift-docs.md`).
- If Cloudflare Workers are used, account for Workers limits, streaming, and security model constraints.
- If Ollama Cloud API or frontier models are used, document provider-specific auth, data handling, and usage constraints.
- Provide guidance for typed clients and schema-driven codegen.
- If CLI is required, follow create-cli conventions (flags, output modes, exit codes).

Use references:
- `references/integration-surfaces.md`
- `references/tech-standards.md`
- `references/auth0-oidc-best-practices.md`
- `references/cloudflare-workers-notes.md`
- `references/ollama-cloud-api.md`
- `references/frontier-models.md`
- `references/data-retention-residency.md`
- `references/rate-limit-templates.md`
- `references/mcp-idempotency-replay.md`
- `references/contract-testing.md`
- `references/security-headers.md`
- `references/audit-log-integrity.md`
- `references/feature-flagging-rollout.md`
- `references/apps-sdk-ux.md`
- `references/apps-sdk-use-cases.md`
- `references/apps-sdk-auth.md`
- `references/apps-sdk-state.md`
- `references/apps-sdk-monetization.md`
- `references/apps-sdk-metadata.md`
- `references/apps-sdk-security-privacy.md`

## Output schema templates
- Use `assets/mcp_tool_schema_template.json` for MCP tool contracts.
- Use `assets/cli_output_schema_template.json` for CLI JSON output contracts.

## Variation rules
- Vary depth by system criticality (prototype vs regulated).
- Vary data design detail by storage complexity.
- Use different validation emphasis for REST vs GraphQL vs hybrid.

## Empowerment principles
- Empower stakeholders with clear trade-offs and decision points.
- Empower implementers with concrete file plans and contracts.

## Anti-patterns to avoid
- Unversioned APIs or breaking changes without deprecation
- Business logic in controllers or route handlers
- Missing idempotency for create or payment flows
- ORM entities leaked across service boundaries
- No telemetry for failures or latency

## Resources
Use the references directory for detailed checklists and patterns. Do not inline large templates in this file.
For GPU/shader pipeline context (when relevant to backend data pipelines or rendering services), see `references/shaders.md`.
For Swift backend context and Swift.org documentation pointers, see `references/swift-docs.md`.
For client integration alignment with SwiftUI and React patterns, see `references/client-integration-swiftui-react.md`.

## Remember

The agent is capable of extraordinary work in this domain. These guidelines unlock that potentialâ€”they don't constrain it.
Use judgment, adapt to context, and push boundaries when appropriate.
